# **path_tracking package**

___

© **SGT Driverless**

**Authors:** Patrik Knaperek

**Objective:** Computing control commands for speed (throttle/brake) and steering angle based on planned trajectory and vehicle state.

___

## Overview

The path tracking problem is divided into two tasks: 
  1. steering control 
  2. speed control

**Steering control**

For steering control, [Pure Pursuit](https://drive.google.com/file/d/1ObsUo9i07dW73RavOTAYJBq5Mh6H2AWu/view?usp=share_link) algorithm is implemented. The steering angle command $\delta_k$ is computed as
   
$$\begin{equation}
\delta_k = \arctan \left(\frac{2 L \sin(\alpha)}{l_d} \right), \nonumber
\end{equation}$$

where $L$ is car length and $\alpha$ is bearing of the point of the reference trajectory in the look-ahead distance $l_d$ from the rear axle. The look-ahead distance changes dynamically as follows:

$$\begin{equation}
l_d = \max \left[l_{d, \min}, \min (l_{d, \max}, k v_{k-1}) \right]. \nonumber
\end{equation}$$

It acts as a low-pass filter of the reference trajectory (the bigger the look-ahead distance value is, the more fluent, "lazy" and possibly imprecise the followed trajectory will be). The algorithm performance can be adjusted by setting the look-ahead distance limits and the $k$ gain.

**Speed control**

The speed command is generated by PID-based controller, however, there are two types available.

By default, assuming lack of knowledge about car's static and dynamic parameters, a **basic PI controller**'s gains can be tuned manually.

In case that transmission characteristics of the vehicle has been measured experimentally and parameters of a 1st order replacement model - gain $K$ and time constant $T$ - have been estimated, we can use an **advanced controller structure** (see figure bellow) consisting of an IP controller and a feed-forward correction loop. The controller's gains are computed based on the Pose Placement method as

$$\begin{align}
K_P & = \frac{2 \xi \omega_0 T - 1}{K} \nonumber, \\
K_I & = \frac{{\omega_0}^2 T}{K} \nonumber.
\end{align}$$

where the natural frequency $\omega_0$ and the damping ratio $\xi$ serve as the performance-definig parameters.

The feed-forward loop serves for elimiation of the control error during reference value change and its parameters are computed as an inverse transfer function of the closed control circuit:

$$\begin{align}
k_1 & = \frac{K_P K + 1}{K_I K} \nonumber, \\
k_2 & = \frac{T}{K_I K} \nonumber.
\end{align}$$

In both cases, the reference speed signal is first processed by a shaping non-linear 2nd order filter which makes a squared input signal into a "s"-curve. It also allows for setting acceleration and jerk limits.

### Diagrams and flowcharts

<figcaption align = "center">Path Tracking algorithm flowchart</figcaption>
<p align="center">
  <img src="./doc/SW flowcharts-Path Tracking.svg" width="900">
</p>

<figcaption align = "center">Speed controller scheme</figcaption>
<p align="center">
  <img src="./doc/SW flowcharts-Path Tracking-speed_control.svg" width="900">
</p>

### ROS Interface

**Subscribed topics**
* `/path_planning/trajectory` [[`sgtdv_msgs/Trajectory`](/src/sgtdv_msgs/msg/Trajectory.msg)] : reference trajectory path (`map` frame) and speed array
* `/odometry/pose` [[`sgtdv_msgs/CarPose`](/src/sgtdv_msgs/msg/CarPose.msg)] : current pose in the global coordinate system
* `/odometry/velocity` [[`sgtdv_msgs/CarVel`](/src/sgtdv_msgs/msg/CarVel.msg)] : current velocity in the `base_link` frame

**Published topics**
* `/path_tracking/cmd` [[`sgtdv_msgs/Control`](/src/sgtdv_msgs/msg/Control.msg)] : speed and steering control command

*If `SGT_VISUALIZE` macro enabled*
* `/path_tracking/visualize/pure_pursuit` [[`visualization_msgs/Marker`](http://docs.ros.org/en/noetic/api/visualization_msgs/html/msg/Marker.html)] : visualization significant points for PP algorithm: target (lookahead) point, the closest trajectory point to the rear axle, rear axle position, front axle position
* `/path_tracking/visualize/steering` [[`geometry_msgs/PoseStamped`](https://docs.ros2.org/latest/api/geometry_msgs/msg/PoseStamped.html)] : visualization of the desired steering pose (rotation)

*If `SGT_DEBUG_STATE` macro enabled*
* `/path_tracking/debug_state` [[`sgtdv_msgs/DebugState`](/src/sgtdv_msgs/msg/DebugState.msg)] : node lifecycle information (active/inactive, current speed and steering command)

**Advertised services**
* `/path_tracking/start` [[`std_srvs/Empty`](http://docs.ros.org/en/noetic/api/std_srvs/html/srv/Empty.html)] : "start moving" command → speed command given by the speed controller
* `/path_tracking/stop` [[`std_srvs/Empty`](http://docs.ros.org/en/noetic/api/std_srvs/html/srv/Empty.html)] : "stop moving" command → speed command equals zero

**Parameters**
* resulting from the setup:
    - `/vehicle/car_length` : distance [m] between axles
    - `/vehicle/rear_wheels_offset` : distance [m] from COG (center of vehicle frame) to the rear axle
    - `/vehicle/front_wheels_offset` : distance [m] from COG (center of vehicle frame) to the front axle
    - `/controller/speed/cmd_min`, `controller/speed/cmd_max` : [%] range of speed control output
    - `/controller/steering/min`, `controller/steering/max` : [rad] range of steering control output
    - `/loop_track` : after reaching the last point of the trajectory, whether to stop or navigate towards the first point again
    - `/controller/speed/advanced/K` : 1st order vehicle model gain
    - `/controller/speed/advanced/T` : 1st order vehicle model time constant
* may be used for controller tuning:
    - `/controller/speed/basic/p` : P gain of speed controller
    - `/controller/speed/basic/i` : I gain of speed controller
    - `/controller/speed/advanced/w0`: control circuit natural frequency (Pole Placement)
    - `/controller/speed/advanced/b`: control circuit damping ratio (Pole Placement)
    - `/controller/speed/ref_sig_shape/a_limit` : reference signal acceleration limit
    - `/controller/speed/ref_sig_shape/j_limit` : reference signal jerk limit
    - `/controller/speed/ref_sig_shape/K1` : jerk shaping factor
    - `/controller/speed/ref_sig_shape/K2` : acceleration shaping factor
    - `/controller/steering/k` : look-ahead distance gain
    - `/controller/steering/smooth` : low-pass filter smoothing factor (0: no filter, 1: full filter)
    - `/controller/steering/lookahead_dist_min`, `/controller/steering/lookahead_dist_max`: look-ahead distance range

### Related packages
* [`path_planning`](/src/path_planning/README.md) : `/path_planning/trajectory` publisher
* [`ptp_trajectory`](/src/ptp_trajectory/README.md) : (alternating `path_planning`) `/path_planning/trajectory` publisher and `path_tracking/start`, `/path_tracking/stop` caller
* [`odometry_interface`](/src/odometry_interface/README.md) : `/odometry/velocity` and `/odometry/pose` publisher
* [`control_si`](/src/simulation_interface/control_si/README.md) : (FSSIM setup) : `/odometry/pose`, `/odometry/velocity` publisher and `/path_tracking/cmd` subscriber
* [`vesc_interface`](/src/racecar_interface/vesc_interface/README.md) : (RC car setup) `/path_tracking/cmd` subscriber
* [`jetson_can_interface`](/src/jetson_can_interface/README.md) : (formula setup) `/path_tracking/cmd` subscriber (*not properly tested yet*)

## Compilation
* standalone
```sh
$ cd ${SGT_ROOT}
$ catkin build path_tracking
```
* RC car setup
```sh
$ source ${SGT_ROOT}/scripts/build_rc.sh
```
* FSSIM setup
```sh
$ source ${SGT_ROOT}/scripts/build_sim.sh
```

### Compilation configuration
* [`SGT_Macros.h`](/src/SGT_Macros.h)
	- `SGT_VISUALIZATION` : publish intermediate calculations on visualizable topics
        - `/path_tracking/visualize/target [visualization_msgs/Marker]` - lookahead (target) point, closest trajectory point, rear wheelbase position, front wheelbase position
        - `/path_tracking/visualize/steering [geometry_msgs/PoseStamped]` - steering angle command
    - `SGT_DEBUG_STATE` : publish node lifecycle information
    

## Launch
* standalone
```sh
$ source ${SGT_ROOT}/ros_implementation/devel/setup.bash
$ roslaunch path_tracking path_tracking.launch
```
* RC car setup
```sh
$ source ${SGT_ROOT}/ros_implementation/devel/setup.bash
$ roslaunch master rc.launch
```
* FSSIM setup (check [FSSIM testing](/doc/FSSIM_testing.md) manual for more info)
```sh
$ source ${SGT_ROOT}/ros_implementation/devel/setup.bash
$ roslaunch master trackdrive.launch
```

To start driving, the trajectory, pose and velocity topics must be active. In a new terminal run
```sh
$ rosservice call /path_tracking/start "{}"
```
### Launch configuration
* [`path_tracking.yaml`](/src/path_tracking/params/path_tracking.yaml) : default setup 
* [`path_tracking_rc.yaml`](/src/path_tracking/params/path_tracking_rc.yaml) : RC car setup
* [`path_tracking_sim.yaml`](/src/path_tracking/params/path_tracking_sim.yaml) : FSSIM setup
